

export default function Article3Page() {


    return (
        <main className="flex-1 overflow-x-hidden">
            <h2 className="text-4xl text-center py-10">Computer Science, Software Development, Bootcamps</h2>
            <img src="../image/web-frameworks.jpg" alt="Scrum Project Board" className="scrum-img" />
            <p className="py-2 text-teal-300">Posted on: January 10, 2024</p>
            <p className="py-2">It's now been almost four years since I began formally learning applied computer science. I started back in January 2021 when COVID was in full force. I was tired and bored working from home, and at that time remote work was not by choice. Had I not been forced to work remotely, I probably would have kept my job as a banking admin. At that time, I asked a coworker about how he transitioned from my admin position to sysadmin because frankly, I loved working with computers but hated my part of the job that involved handling paper. He told me to take an SQL class from British Columbia Institute of Technology.</p>
            <p className="py-2">Looking back, I'm curious as to why he told me to take the Relational Database Design and SQL class. Since I didn't know any better, I took the Applied Computer Concepts course (the introductory course for computing at BCIT for normies teaching basic I/O devices and computers and networks at a high level) which I passed with flying colors barely studying for it, then I took the SQL course as suggested and bombed it because it really didn't make much sense to me back then, especially when they started talking about triggers.</p>
            <p>But that sparked something in me and I decided to take Fundamentals of Programming with Python. I instantly fell in love with it and by the end I was off building 2D games with pygame even though I didn't fully understand Python and OOP. By then I knew I wanted to learn programming and changed my goal of becoming a sysadmin to becoming a software developer. I took OOP with Java, OO design with Java, and procedural programming with C (at that time, a traumatizing experience for someone who wasn't familiar with computer architecture. I seriously think anyone learning C should learn computer architecture beforehand so they don't get lost in the preprocessing, assembly, linking, loading, execution, pointers, malloc, calloc, realloc, stacks, queues, heap, and linked list mechanisms).</p>
            <p>Introduction to web dev with HTML and CSS was a nice recovery period from learning C. Web development with JavaScript was a breeze after Java and C. Frontend Web Development with React and Backend Development with Node were fascinating and were ultimately the tools that would make me a professional full stack developer.</p>
            <p>Now, by this time, I had already been studying at BCIT for over two years. I noticed during the React and Node courses that those who only learned web development had a harder time troubleshooting and analysing bugs and crashes than those who learned fundamentals of programming with other programming languages. That's when I realized how important it is to spend time programming in at least a few diverse languages where some are dynamically typed, others are statically typed, loosely typed vs strictly typed, more abstracted vs less abstracted, and compiled vs interpreted.</p>
            <p>But what's even more important is understanding why these differences in languages exist, and why the languages themselves exist. What are the strengths and weaknesses of each? Why use one language to solve one type of problem over another, while using another language to solve another type of problem? Why use JavaScript in the frontend instead of a server-side rendered templating engine from another language? Why use Java Spring boot or ASP.NET or Go in favor of Node or Ruby on Rails? Why use Python for machine learning? Why use C# and Unity engine or C++ and Unreal engine for game development? Why use C for embedded systems? It's important to understand how these codes are compiled or interpreted into machine code and how the CPU handles these instruction sets. It's important to know, albeit on the surface level, the history of computing and how we arrived at today's technology from Blaise Pascal's mechanical calculator to Leibnitz's machine to Babbage and Ada, the Turing machine, Baarden's transistor and IBM computers. And I think this is the point at which bootcamps stop teaching. I have 60 completed credits at BCIT so far, and I have yet to take the Operating Systems and Data Communications classes, which I'm planning to take in the next couple of terms. But even though I didn't take these classes yet, I understand their importance and the need to understand them very soon. I have been programming and developing non-stop for the past four years, and the more I build applications, the more I realize the importance of the fundamentals of computer science.</p>
            <p>As big tech companies layoff tens of thousands of developers and the number of developers in the market increase proportionally to demand, we've come to a crucial point where bootcamp education, or at least what they have been delivering so far, is simply insufficient. I'm not saying that bootcamps shouldn't exist or are useless. Rather, I'm saying that maybe they should change the content and material they are teaching within those 6 months. It's simply not enough teaching students HTML, CSS, JS, React and Node or Go. A good amount of time should be spent teaching them to understand computer architecture, operating systems and networking fundamentals, as well as algorithm analysis. These are the foundations of computer science, and it's really hard to become a developer in these times without having a good understanding of them. Having said this, it is equally important to spend enough time building various complex projects with immediately applicable tech stacks such as React and Node and their various packages. It's important to have experience designing, building, optimizing, and deploying these applications in the real world for real users to use. The challenge would be to fit both worlds into the 6-month time period. Is it possible? Well... it certainly won't be easy.</p>
        </main>
    )
}